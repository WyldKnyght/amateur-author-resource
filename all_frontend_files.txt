
================================================================================
## FILE: frontend/src\App.css

/* frontend/src/App.css
/* Core styles for App, authentication, loading, and dashboard UI */

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  background: #f8f9fa;
  color: #333;
  margin: 0;
  min-height: 100vh;
}

.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}
.main-content {
  flex: 1;
}

/* Authentication styles */
.auth-container {
  min-height: 80vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}
.auth-card {
  background: white;
  border-radius: 12px;
  box-shadow: 0 4px 6px rgba(0,0,0,0.08);
  padding: 40px;
  width: 100%;
  max-width: 400px;
}
.auth-card h2 { text-align: center; margin-bottom: 8px; color: #1a1a1a;}
.auth-form { display: flex; flex-direction: column; gap: 20px;}
.form-group { display: flex; flex-direction: column; gap: 6px;}
.form-group label { font-weight: 600; }
.auth-button {
  background-color: #3b82f6;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.2s;
  text-align: center;
}
.auth-button:disabled { background-color: #9ca3af; cursor: not-allowed; }
.auth-link { text-align: center; margin-top: 14px; color: #666; }
.auth-link a { color: #3b82f6; text-decoration: none; }

.error-message {
  background-color: #fef2f2;
  color: #dc2626;
  padding: 12px;
  border-radius: 8px;
  border: 1px solid #fecaca;
  font-size: 14px;
}

/* Loading */
.loading-container {
  display: flex; flex-direction: column; align-items: center; min-height: 200px; gap: 16px;
}
.loading-spinner {
  width: 40px; height: 40px;
  border: 4px solid #e5e7eb;
  border-top: 4px solid #3b82f6;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* Home & dashboard styles can be extended as needed */


================================================================================
## FILE: frontend/src\App.tsx

// frontend/src/App.tsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from "./context/AuthContext"; 
import ProtectedRoute from './components/ProtectedRoute';
import LoginForm from './components/auth/LoginForm';
import Dashboard from './pages/Dashboard';
import ProjectsDashboard from './pages/ProjectsDashboard';
import ProjectEditorPage from './pages/ProjectEditorPage';
import HomePage from './pages/HomePage';
import RegisterPage from './pages/RegisterPage'; // Import the new page
import './App.css';

const App: React.FC = () => {
  return (
    <Router>
      <AuthProvider>
        <div className="app">
          <main className="main-content">
            <Routes>
              <Route path="/login" element={<LoginForm />} />
              <Route path="/register" element={<RegisterPage />} /> {/* Add this line */}
              <Route path="/home" element={<HomePage />} />
              <Route path="/dashboard" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />
              <Route path="/projects" element={<ProtectedRoute><ProjectsDashboard /></ProtectedRoute>} />
              <Route path="/projects/:projectId/editor" element={<ProtectedRoute><ProjectEditorPage /></ProtectedRoute>} />
              <Route path="*" element={<Navigate to="/login" />} />
            </Routes>
          </main>
        </div>
      </AuthProvider>
    </Router>
  );
};

export default App;

================================================================================
## FILE: frontend/src\main.tsx

// frontend/src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


================================================================================
## FILE: frontend/src\components\ProtectedRoute.tsx

// frontend/src/components/ProtectedRoute.tsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';
import LoadingSpinner from './common/LoadingSpinner';

interface ProtectedRouteProps {
  children: JSX.Element;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return children;
};

export default ProtectedRoute;
================================================================================
## FILE: frontend/src\components\auth\LoginForm.tsx

// frontend/src/components/auth/LoginForm.tsx
import React, { useState } from 'react';
import { useAuth } from '@/hooks/useAuth';
import { Link, useNavigate } from 'react-router-dom';
import ErrorMessage from '../common/ErrorMessage';

const LoginForm: React.FC = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const { login } = useAuth();
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);

    try {
      const success = await login(username, password);
      if (success) {
        navigate('/dashboard');
      } else {
        setError('Invalid username or password');
      }
    } catch {
      setError('Login failed. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="auth-container">
      <div className="auth-card">
        <h2>Welcome Back</h2>
        <p>Sign in to your Fiction Platform account</p>
        <form onSubmit={handleSubmit} className="auth-form">
          <div className="form-group">
            <label htmlFor="username">Username</label>
            <input
              id="username"
              type="text"
              placeholder="Enter your username"
              value={username}
              onChange={e => setUsername(e.target.value)}
              required
              disabled={isLoading}
            />
          </div>
          <div className="form-group">
            <label htmlFor="password">Password</label>
            <input
              id="password"
              type="password"
              placeholder="Enter your password"
              value={password}
              onChange={e => setPassword(e.target.value)}
              required
              disabled={isLoading}
            />
          </div>
          <ErrorMessage message={error} />
          <button type="submit" disabled={isLoading} className="auth-button">
            {isLoading ? 'Signing in...' : 'Sign In'}
          </button>
        </form>
        <p className="auth-link">
          Don't have an account? <Link to="/register">Sign up here</Link>
        </p>
      </div>
    </div>
  );
};

export default LoginForm;

================================================================================
## FILE: frontend/src\components\auth\RegisterForm.tsx

// frontend/src/components/auth/RegisterForm.tsx
import React, { useState } from 'react';
import { useAuth } from '@/hooks/useAuth';
import { Link, useNavigate } from 'react-router-dom';
import ErrorMessage from '../common/ErrorMessage';

const RegisterForm: React.FC = () => {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const { register } = useAuth();
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }
    if (password.length < 8) {
      setError('Password must be at least 8 characters long');
      return;
    }
    setIsLoading(true);

    try {
      const success = await register(username, email, password);
      if (success) {
        navigate('/login', {
          state: { message: 'Account created successfully! Please log in.' }
        });
      } else {
        setError('Registration failed. Username or email may already exist.');
      }
    } catch {
      setError('Registration failed. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="auth-container">
      <div className="auth-card">
        <h2>Join Fiction Platform</h2>
        <p>Create your account to start writing</p>
        <form onSubmit={handleSubmit} className="auth-form">
          <div className="form-group">
            <label htmlFor="username">Username</label>
            <input
              id="username"
              type="text"
              placeholder="Choose a username"
              value={username}
              onChange={e => setUsername(e.target.value)}
              required
              minLength={3}
              maxLength={50}
              disabled={isLoading}
            />
          </div>
          <div className="form-group">
            <label htmlFor="email">Email</label>
            <input
              id="email"
              type="email"
              placeholder="Enter your email"
              value={email}
              onChange={e => setEmail(e.target.value)}
              required
              disabled={isLoading}
            />
          </div>
          <div className="form-group">
            <label htmlFor="password">Password</label>
            <input
              id="password"
              type="password"
              placeholder="Create a password (8+ characters)"
              value={password}
              onChange={e => setPassword(e.target.value)}
              required
              minLength={8}
              disabled={isLoading}
            />
          </div>
          <div className="form-group">
            <label htmlFor="confirmPassword">Confirm Password</label>
            <input
              id="confirmPassword"
              type="password"
              placeholder="Confirm your password"
              value={confirmPassword}
              onChange={e => setConfirmPassword(e.target.value)}
              required
              disabled={isLoading}
            />
          </div>
          <ErrorMessage message={error} />
          <button type="submit" disabled={isLoading} className="auth-button">
            {isLoading ? 'Creating account...' : 'Create Account'}
          </button>
        </form>
        <p className="auth-link">
          Already have an account? <Link to="/login">Sign in here</Link>
        </p>
      </div>
    </div>
  );
};

export default RegisterForm;

================================================================================
## FILE: frontend/src\components\common\ErrorMessage.tsx

// frontend/src/components/common/ErrorMessage.tsx
import React from 'react';

interface ErrorMessageProps {
  message: string;
}

const ErrorMessage: React.FC<ErrorMessageProps> = ({ message }) =>
  message ? <div className="error-message">{message}</div> : null;

export default ErrorMessage;

================================================================================
## FILE: frontend/src\components\common\LoadingSpinner.tsx

// src/components/common/LoadingSpinner.tsx
import React from "react";

const LoadingSpinner: React.FC = () => (
  <div className="loading-container">
    <div className="loading-spinner" />
    <p>Loading...</p>
  </div>
);

export default LoadingSpinner;

================================================================================
## FILE: frontend/src\components\projects\CreateProjectForm.tsx

// src/components/projects/CreateProjectForm.tsx
import React, { useState } from "react";
import { GENRE_OPTIONS, STATUS_OPTIONS } from "../../types/project-types";

interface Props {
  onSubmit: (projectData: any) => void;
  onCancel: () => void;
}

const CreateProjectForm: React.FC<Props> = ({ onSubmit, onCancel }) => {
  const [title, setTitle] = useState("");
  const [description, setDescription] = useState("");
  const [genre, setGenre] = useState<string>(GENRE_OPTIONS[0]);
  const [status, setStatus] = useState<"draft" | "in_progress" | "completed" | "published">(STATUS_OPTIONS[0].value);
  const [targetWordCount, setTargetWordCount] = useState<number | "">("");
  interface FormErrors {
    title?: string;
  }
  
  const [errors, setErrors] = useState<FormErrors>({});

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim()) {
      setErrors({ title: "Title is required" });
      return;
    }
    onSubmit({ title, description, genre, status, targetWordCount });
  };

  return (
    <form onSubmit={handleSubmit} className="project-form">
      <h2>Create New Project</h2>
      <label>
        Title
        <input
          value={title}
          onChange={e => setTitle(e.target.value)}
          required
        />
        {errors.title && <span className="error">{errors.title}</span>}
      </label>
      <label>
        Description
        <textarea
          value={description}
          onChange={e => setDescription(e.target.value)}
        />
      </label>
      <label>
        Genre
        <select value={genre} onChange={e => setGenre(e.target.value)}>
          {GENRE_OPTIONS.map(opt => <option key={opt} value={opt}>{opt}</option>)}
        </select>
      </label>
      <label>
        Status
        <select value={status} onChange={e => setStatus(e.target.value as "draft" | "in_progress" | "completed" | "published")}>
          {STATUS_OPTIONS.map(opt => (
            <option key={opt.value} value={opt.value}>
              {opt.label}
            </option>
          ))}
        </select>
      </label>
      <label>
        Target Word Count
        <input
          type="number"
          min="0"
          value={targetWordCount}
          onChange={e => setTargetWordCount(Number(e.target.value))}
        />
      </label>
      <div className="form-actions">
        <button type="submit" className="btn-primary">Create</button>
        <button type="button" className="btn-secondary" onClick={onCancel}>Cancel</button>
      </div>
    </form>
  );
};

export default CreateProjectForm;

================================================================================
## FILE: frontend/src\components\projects\DeleteProjectModal.tsx

// src/components/projects/DeleteProjectModal.tsx
import React from "react";
import { Project } from "../../types/project-types";

interface Props {
  project: Project | null;
  onConfirm: () => void;
  onCancel: () => void;
}

const DeleteProjectModal: React.FC<Props> = ({ project, onConfirm, onCancel }) => {
  if (!project) {
    return null;
  }
  return (
    <div className="modal-overlay">
      <div className="modal">
        <h2>Delete Project</h2>
        <p>
// sourcery skip: only-delete-object-properties
          Are you sure you want to delete "<strong>{project.title}</strong>"?
          This action cannot be undone.
        </p>
        <div className="modal-actions">
          <button className="btn-danger" onClick={onConfirm}>Remove</button>
          <button className="btn-secondary" onClick={onCancel}>Cancel</button>
        </div>
      </div>
    </div>
  );
};

export default DeleteProjectModal;

================================================================================
## FILE: frontend/src\components\projects\ProjectList.tsx

// src/components/projects/ProjectList.tsx
import React from "react";
import { Project } from "../../types/project-types";

interface Props {
  projects: Project[];
  isLoading: boolean;
  onProjectSelect: (id: number) => void;
  onProjectEdit?: (proj: Project) => void;
  onProjectDelete?: (id: number) => void;
  showCreateButton?: boolean;
  onCreateNew?: () => void;
}

const ProjectList: React.FC<Props> = ({
  projects,
  isLoading,
  onProjectSelect,
  onProjectEdit,
  onProjectDelete,
  showCreateButton,
  onCreateNew,
}) => {
  if (isLoading) return <div>Loading...</div>;
  if (!projects.length)
    return <div>No projects found.</div>;

  return (
    <div className="project-list">
      {showCreateButton && (
        <button className="btn-primary" onClick={onCreateNew}>
          Create New Project
        </button>
      )}
      <ul>
        {projects.map(project => (
          <li key={project.id} className="project-card">
            <span onClick={() => onProjectSelect(project.id)}>
              {project.title}
            </span>
            {onProjectEdit && (
              <button onClick={() => onProjectEdit(project)}>
                Edit
              </button>
            )}
            {onProjectDelete && (
              <button onClick={() => onProjectDelete(project.id)}>
                Delete
              </button>
            )}
          </li>
        ))}
      </ul>
    </div>
  );
};

export default ProjectList;

================================================================================
## FILE: frontend/src\context\AuthContext.tsx

// src/context/AuthContext.tsx
import React, { createContext, useContext, useState, useEffect } from "react";
import { AuthContextType, User } from "../types/auth-types";

export const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [authError, setAuthError] = useState<string>("");

  useEffect(() => { checkAuth(); }, []);

  // Always send Authorization: Bearer <token>
  const checkAuth = async () => {
    setIsLoading(true);
    try {
      const token = localStorage.getItem("access_token");
      const response = await fetch("/api/auth/me", {
        headers: token ? { Authorization: `Bearer ${token}` } : {}
      });
      if (response.ok) {
        setUser(await response.json());
        setAuthError("");
      } else {
        setUser(null);
      }
    } catch {
      setUser(null);
    }
    setIsLoading(false);
  };

  const login = async (username: string, password: string): Promise<boolean> => {
    setAuthError("");
    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password })
      });
      if (response.ok) {
        const data = await response.json();
        localStorage.setItem("access_token", data.access_token); // Store token!
        await checkAuth();
        return true;
      }
      setAuthError("Invalid username or password");
      return false;
    } catch {
      setAuthError("Login failed. Please try again.");
      return false;
    }
  };

  const register = async (username: string, email: string, password: string): Promise<boolean> => {
    setAuthError("");
    try {
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, email, password })
      });
      if (response.ok) {
        const data = await response.json();
        localStorage.setItem("access_token", data.access_token); // Store token!
        await checkAuth();
        return true;
      }
      setAuthError("Registration failed. Username or email may already exist.");
      return false;
    } catch {
      setAuthError("Registration failed. Please try again.");
      return false;
    }
  };

  const logout = async () => {
    try { await fetch("/api/auth/logout", { method: "POST" }); } catch {}
    setUser(null);
    localStorage.removeItem("access_token");
    setAuthError("");
  };

  return (
    <AuthContext.Provider value={{
      user,
      isAuthenticated: !!user,
      login,
      register,
      logout,
      isLoading,
      authError,
      clearAuthError: () => setAuthError("")
    }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};

================================================================================
## FILE: frontend/src\hooks\useAuth.tsx

// frontend/src/hooks/useAuth.tsx
import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext';

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================================================================================
## FILE: frontend/src\hooks\useProjects.tsx

// frontend/src/hooks/useProjects.tsx
import { useState, useEffect, useCallback } from 'react';
import {
  Project, ProjectCreate, ProjectUpdate, ProjectFilters,
  ProjectListState, ProjectWithContent, ProjectStats
} from '../types/project-types';
import { projectAPI, handleApiError } from '../services/project-api';

// Projects list and CRUD hook
export const useProjects = (initialFilters: ProjectFilters = {}) => {
  const [state, setState] = useState<ProjectListState>({
    projects: [],
    isLoading: false,
    error: undefined,
    filters: { limit: 10, skip: 0, ...initialFilters },
    pagination: { page: 1, size: 0, total: 0, pages: 0 }
  });

  const fetchProjects = useCallback(async (filters?: ProjectFilters) => {
    setState(prev => ({ ...prev, isLoading: true, error: undefined }));
    try {
      const filtersToUse = { ...state.filters, ...filters };
      const response = await projectAPI.getProjects(filtersToUse);
      setState(prev => ({
        ...prev,
        projects: response.projects,
        isLoading: false,
        filters: filtersToUse,
        pagination: {
          page: response.page,
          size: response.size,
          total: response.total,
          pages: response.pages
        }
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: handleApiError(error)
      }));
    }
  }, [state.filters]);

  const createProject = useCallback(async (projectData: ProjectCreate): Promise<Project | null> => {
    try {
      const newProject = await projectAPI.createProject(projectData);
      setState(prev => ({
        ...prev,
        projects: [newProject, ...prev.projects],
        pagination: { ...prev.pagination, total: prev.pagination.total + 1 }
      }));
      return newProject;
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: handleApiError(error)
      }));
      return null;
    }
  }, []);

  const updateProject = useCallback(async (projectId: number, projectData: ProjectUpdate): Promise<Project | null> => {
    try {
      const updatedProject = await projectAPI.updateProject(projectId, projectData);
      setState(prev => ({
        ...prev,
        projects: prev.projects.map(project =>
          project.id === projectId ? updatedProject : project
        )
      }));
      return updatedProject;
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: handleApiError(error)
      }));
      return null;
    }
  }, []);

  const deleteProject = useCallback(async (projectId: number): Promise<boolean> => {
    try {
      await projectAPI.deleteProject(projectId);
      setState(prev => ({
        ...prev,
        projects: prev.projects.filter(project => project.id !== projectId),
        pagination: { ...prev.pagination, total: prev.pagination.total - 1 }
      }));
      return true;
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: handleApiError(error)
      }));
      return false;
    }
  }, []);

  const setFilters = useCallback((filters: Partial<ProjectFilters>) => {
    const newFilters = { ...state.filters, ...filters, skip: 0 };
    fetchProjects(newFilters);
  }, [fetchProjects, state.filters]);

  const setPage = useCallback((page: number) => {
    const skip = (page - 1) * (state.filters.limit || 10);
    fetchProjects({ ...state.filters, skip });
  }, [fetchProjects, state.filters]);

  const refreshProjects = useCallback(() => { fetchProjects(); }, [fetchProjects]);
  const clearError = useCallback(() => { setState(prev => ({ ...prev, error: undefined })); }, []);

  useEffect(() => { fetchProjects(); }, []);
  return {
    ...state,
    createProject,
    updateProject,
    deleteProject,
    setFilters,
    setPage,
    refreshProjects,
    clearError
  };
};

// Single project detail hook
export const useProject = (projectId: number) => {
  const [project, setProject] = useState<ProjectWithContent | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | undefined>();

  const fetchProject = useCallback(async () => {
    setIsLoading(true);
    setError(undefined);
    try {
      const projectData = await projectAPI.getProject(projectId);
      setProject(projectData);
    } catch (err) {
      setError(handleApiError(err));
    } finally {
      setIsLoading(false);
    }
  }, [projectId]);

  const updateProject = useCallback(async (projectData: ProjectUpdate): Promise<boolean> => {
    try {
      const updatedProject = await projectAPI.updateProject(projectId, projectData);
      setProject(prev => prev ? { ...prev, ...updatedProject } : updatedProject);
      return true;
    } catch (err) {
      setError(handleApiError(err));
      return false;
    }
  }, [projectId]);

  const refreshProject = useCallback(() => {
    fetchProject();
  }, [fetchProject]);

  const clearError = useCallback(() => {
    setError(undefined);
  }, []);

  useEffect(() => {
    if (projectId) {
      fetchProject();
    }
  }, [projectId, fetchProject]);

  return {
    project,
    isLoading,
    error,
    updateProject,
    refreshProject,
    clearError
  };
};

// Project statistics hook
export const useProjectStats = (projectId: number) => {
  const [stats, setStats] = useState<ProjectStats | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | undefined>();

  const fetchStats = useCallback(async () => {
    if (!projectId) {
      return;
    }
    setIsLoading(true);
    setError(undefined);
    try {
      const statsData = await projectAPI.getProjectStats(projectId); // FIXED
      setStats(statsData); // Use this state for results
    } catch (err) {
      setError(handleApiError(err));
    } finally {
      setIsLoading(false);
    }
  }, [projectId]);

  const refreshStats = useCallback(() => {
    fetchStats();
  }, [fetchStats]);

  useEffect(() => {
    fetchStats();
  }, [fetchStats]);

  return {
    stats, isLoading, error, refreshStats
  };
};

================================================================================
## FILE: frontend/src\hooks\useStoryContent.tsx

// frontend/src/hooks/useStoryContent.tsx
import { useState, useEffect, useCallback, useRef } from 'react';
import { ProjectEditorState, StoryContent } from '../types/project-types';
import { handleApiError, AutoSaveManager, projectAPI } from '../services/project-api';

export const useStoryContent = (projectId: number, autoSaveDelay: number = 3000) => {
  const [state, setState] = useState<ProjectEditorState>({
    isLoading: false,
    isSaving: false,
    isAutoSaving: false,
    hasUnsavedChanges: false,
    lastSaved: undefined,
    error: undefined,
    content: null
  });
  const autoSaveManager = useRef<AutoSaveManager | null>(null);
  const lastSavedContent = useRef<string>('');

  useEffect(() => {
    if (projectId) {
      autoSaveManager.current = new AutoSaveManager(projectId, autoSaveDelay);
    }
    return () => {
      if (autoSaveManager.current) {
        autoSaveManager.current.destroy();
      }
    };
  }, [projectId, autoSaveDelay]);

  const loadContent = useCallback(async () => {
    if (!projectId) {
      return;
    }
    setState(prev => ({ ...prev, isLoading: true, error: undefined }));
    try {
      const contentData = await projectAPI.getStoryContent(projectId);
      setState(prev => ({
        ...prev,
        isLoading: false,
        content: contentData,
        hasUnsavedChanges: false,
        lastSaved: contentData.updated_at
      }));
      lastSavedContent.current = contentData.content || '';
    } catch (error) {
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: handleApiError(error)
      }));
    }
  }, [projectId]);

  const updateContent = useCallback((newContent: string) => {
    setState(prev => ({
      ...prev,
      content: prev.content ? { ...prev.content, content: newContent } : null,
      hasUnsavedChanges: newContent !== lastSavedContent.current,
      error: undefined
    }));
    if (newContent !== lastSavedContent.current && autoSaveManager.current) {
      setState(prev => ({ ...prev, isAutoSaving: true }));
      autoSaveManager.current.scheduleAutoSave(newContent, () => {
        setState(prev => ({
          ...prev,
          isAutoSaving: false,
          lastSaved: new Date().toISOString()
        }));
        lastSavedContent.current = newContent;
      });
    }
  }, []);

  const saveContent = useCallback(async (): Promise<boolean> => {
    if (!state.content) {
      return false;
    }
    const contentToSave = state.content.content || '';
    setState(prev => ({ ...prev, isSaving: true, error: undefined }));
    try {
      const savedContent = await projectAPI.saveStoryContent(projectId, { content: contentToSave });
      setState(prev => ({
        ...prev,
        isSaving: false,
        hasUnsavedChanges: false,
        lastSaved: savedContent.updated_at,
        content: savedContent
      }));
      lastSavedContent.current = contentToSave;
      autoSaveManager.current?.cancel();
      return true;
    } catch (error) {
      setState(prev => ({
        ...prev,
        isSaving: false,
        error: handleApiError(error)
      }));
      return false;
    }
  }, [projectId, state.content]);

  const createVersion = useCallback(async (): Promise<boolean> => {
    try {
      await projectAPI.createContentVersion(projectId);
      return true;
    } catch (error) {
      setState(prev => ({ ...prev, error: handleApiError(error) }));
      return false;
    }
  }, [projectId]);

  const clearError = useCallback(() => {
    setState(prev => ({ ...prev, error: undefined }));
  }, []);
  const refreshContent = useCallback(() => { loadContent(); }, [loadContent]);

  const handleKeyboardShortcuts = useCallback((event: KeyboardEvent) => {
    if ((event.ctrlKey || event.metaKey) && event.key === 's') {
      event.preventDefault();
      saveContent();
    }
  }, [saveContent]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyboardShortcuts);
    return () => window.removeEventListener('keydown', handleKeyboardShortcuts);
  }, [handleKeyboardShortcuts]);

  useEffect(() => { loadContent(); }, [loadContent]);

  useEffect(() => {
    const handleBeforeUnload = (event: BeforeUnloadEvent) => {
      if (state.hasUnsavedChanges) {
        event.preventDefault();
        event.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
      }
    };
    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [state.hasUnsavedChanges]);

  return {
    ...state,
    updateContent,
    saveContent,
    createVersion,
    clearError,
    refreshContent,
    loadContent
  };
};

export const useContentVersions = (projectId: number) => {
  const [versions, setVersions] = useState<StoryContent[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | undefined>();

  const fetchVersions = useCallback(async () => {
    if (!projectId) {
      return;
    }
    setIsLoading(true);
    setError(undefined);
    try {
      const versionData = await projectAPI.getContentVersions(projectId);
      setVersions(versionData);
    } catch (err) {
      setError(handleApiError(err));
    } finally {
      setIsLoading(false);
    }
  }, [projectId]);

  const refreshVersions = useCallback(() => {
    fetchVersions();
  }, [fetchVersions]);

  useEffect(() => {
    fetchVersions();
  }, [fetchVersions]);

  return {
    versions,
    isLoading,
    error,
    refreshVersions,
  };
};

================================================================================
## FILE: frontend/src\pages\Dashboard.css

/* Dashboard.css - Styling for the main dashboard */
.dashboard {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.dashboard-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 30px;
  padding-bottom: 20px;
  border-bottom: 2px solid #e1e5e9;
}

.dashboard-header h1 {
  color: #2c3e50;
  font-size: 2rem;
  margin: 0;
}

.dashboard-actions {
  display: flex;
  gap: 15px;
}

.btn-primary, .btn-secondary {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 500;
  text-decoration: none;
  display: inline-block;
  transition: background-color 0.3s ease;
}

.btn-primary {
  background-color: #3498db;
  color: white;
}

.btn-primary:hover {
  background-color: #2980b9;
}

.btn-secondary {
  background-color: #95a5a6;
  color: white;
}

.btn-secondary:hover {
  background-color: #7f8c8d;
}

.dashboard-content {
  display: grid;
  gap: 30px;
}

.analytics-section h2,
.recent-projects h2 {
  color: #2c3e50;
  margin-bottom: 20px;
  font-size: 1.5rem;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 20px;
  margin-bottom: 30px;
}

.stat-card {
  background: white;
  padding: 25px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  text-align: center;
  border: 1px solid #e1e5e9;
}

.stat-card h3 {
  font-size: 2rem;
  color: #3498db;
  margin: 0 0 10px 0;
  font-weight: bold;
}

.stat-card p {
  color: #7f8c8d;
  margin: 0;
  font-weight: 500;
}

.empty-state {
  text-align: center;
  padding: 40px;
  background: #f8f9fa;
  border-radius: 8px;
  border: 2px dashed #dee2e6;
}

.empty-state p {
  color: #6c757d;
  font-size: 1.1rem;
  margin-bottom: 20px;
}

================================================================================
## FILE: frontend/src\pages\Dashboard.tsx

// frontend/src/pages/Dashboard.tsx
import React, { useEffect, useState } from 'react';
import { useNavigate, Link } from "react-router-dom";
import { useAuth } from '@/hooks/useAuth';
import { useProjects } from '@/hooks/useProjects';
import ProjectList from '@/components/projects/ProjectList';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorMessage from '@/components/common/ErrorMessage';

interface DashboardData {
  message: string;
  user: {
    id: number;
    username: string;
    email: string;
    member_since: string;
  };
  stats: {
    projects: number;
    characters: number;
    word_count: number;
  };
}

interface UserStats {
  totalProjects: number;
  totalWords: number;
  averageWordsPerProject: number;
  lastUpdated: string;
}

const Dashboard: React.FC = () => {
  const { user, logout } = useAuth();
  const {
    projects,
    isLoading: projectsLoading,
    error: projectsError,
    refreshProjects
  } = useProjects();
  const [dashboardData, setDashboardData] = useState<DashboardData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [stats, setStats] = useState<UserStats>({
    totalProjects: 0,
    totalWords: 0,
    averageWordsPerProject: 0,
    lastUpdated: new Date().toISOString(),
  });
  const navigate = useNavigate();

  // Fetch dashboard data from API
  useEffect(() => {
    fetchDashboardData();
    refreshProjects();
    // eslint-disable-next-line
  }, []);

  const fetchDashboardData = async () => {
    try {
      const token = localStorage.getItem("access_token");
      const response = await fetch("/api/users/dashboard", {
        headers: token ? { Authorization: `Bearer ${token}` } : {}
    });

      if (response.ok) {
        const data = await response.json();
        setDashboardData(data);
      }
    } catch {
      // Optionally handle fetch errors here
    } finally {
      setIsLoading(false);
    }
  };

  // Calculate stats from projects (if available)
  useEffect(() => {
    if (projects.length > 0) {
      const totalWords = projects.reduce((sum, project) => sum + (project.word_count || 0), 0);
      const avgWords = Math.round(totalWords / projects.length);
      setStats({
        totalProjects: projects.length,
        totalWords,
        averageWordsPerProject: avgWords,
        lastUpdated: new Date().toISOString(),
      });
    }
  }, [projects]);

  const handleLogout = async () => {
    await logout();
    navigate("/login");
  };

  if (isLoading || projectsLoading) {
    return (
      <div className="loading-container">
        <LoadingSpinner />
        <p>Loading your dashboard...</p>
      </div>
    );
  }
  if (projectsError) {
    return <ErrorMessage message={projectsError} />;
  }

  return (
    <div className="dashboard">
      <div className="container">
        <header className="dashboard-header">
          <div>
            <h1>Welcome back, {user?.username}!</h1>
            <p>Ready to continue your writing journey?</p>
          </div>
          <button onClick={handleLogout} className="logout-button">Sign Out</button>
        </header>

        {/* Backend dashboard API message and account info */}
        <div>
          <p>{dashboardData?.message}</p>
          {dashboardData?.user && (
            <p>Member since: {dashboardData.user.member_since}</p>
          )}
        </div>

        {/* Analytics Section */}
        <section className="analytics-section">
          <h2>Your Writing Analytics</h2>
          <div className="stats-grid">
            <div className="stat-card"><h3>{stats.totalProjects}</h3><p>Total Projects</p></div>
            <div className="stat-card"><h3>{stats.totalWords.toLocaleString()}</h3><p>Total Words Written</p></div>
            <div className="stat-card"><h3>{stats.averageWordsPerProject.toLocaleString()}</h3><p>Average Words per Project</p></div>
            <div className="stat-card"><h3>{new Date(stats.lastUpdated).toLocaleDateString()}</h3><p>Last Updated</p></div>
          </div>
        </section>

        {/* Recent Projects Section */}
        <section className="recent-projects">
          <h2>Recent Projects</h2>
          {projects.length === 0 ? (
            <div className="empty-state">
              <p>No projects yet. Create your first story project!</p>
              <Link to="/projects" className="btn-primary">Create Project</Link>
            </div>
          ) : (
            <ProjectList
              projects={projects.slice(0, 5)}
              isLoading={projectsLoading}
              showCreateButton={false}
              onProjectSelect={id => navigate(`/projects/${id}`)}
              // Provide dummy or real implementations for other required props
              onProjectEdit={() => {}}
              onProjectDelete={() => {}}
            />
          )}
        </section>
      </div>
    </div>
  );
};

export default Dashboard;

================================================================================
## FILE: frontend/src\pages\HomePage.tsx

// frontend/src/pages/HomePage.tsx
import React from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '@/hooks/useAuth';

const HomePage: React.FC = () => {
  const { user } = useAuth();

  return (
    <div className="home-page">
      <header className="hero-section">
        <div className="container">
          <h1>Fiction Platform</h1>
          <p className="hero-subtitle">
            Empower your creative journey with comprehensive writing tools
          </p>
          <p className="hero-description">
            A free, open-source platform designed for fiction writers of all levels. 
            Plan, create, edit, and organize your stories with ease.
          </p>
          {user ? (
            <Link to="/dashboard" className="cta-button">
              Go to Dashboard
            </Link>
          ) : (
            <div className="cta-buttons">
              <Link to="/register" className="cta-button primary">
                Get Started Free
              </Link>
              <Link to="/login" className="cta-button secondary">
                Sign In
              </Link>
            </div>
          )}
        </div>
      </header>
      {/* Additional features and sections can be included here */}
    </div>
  );
};

export default HomePage;


================================================================================
## FILE: frontend/src\pages\ProjectEditorPage.css

/* ProjectEditorPage.css - Enhanced styling for the project editor */
.project-editor {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: #f8f9fa;
}

.editor-header {
  background: white;
  padding: 15px 25px;
  border-bottom: 1px solid #e1e5e9;
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.editor-info {
  display: flex;
  align-items: center;
  gap: 20px;
  font-weight: 500;
}

.word-count {
  color: #6c757d;
  font-size: 0.9rem;
}

.auto-save-status {
  font-size: 0.85rem;
  padding: 4px 8px;
  border-radius: 4px;
}

.auto-save-status.saving {
  background-color: #fff3cd;
  color: #856404;
}

.auto-save-status.saved {
  background-color: #d1edff;
  color: #0c5460;
}

.auto-save-status.error {
  background-color: #f8d7da;
  color: #721c24;
}

.editor-content {
  flex: 1;
  padding: 25px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  overflow-y: auto;
}

.project-meta {
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  border: 1px solid #e1e5e9;
}

.title-input {
  width: 100%;
  padding: 12px;
  border: 1px solid #ced4da;
  border-radius: 6px;
  font-size: 1.2rem;
  font-weight: bold;
  margin-bottom: 15px;
  color: #2c3e50;
}

.title-input:focus {
  outline: none;
  border-color: #3498db;
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

.description-input {
  width: 100%;
  padding: 12px;
  border: 1px solid #ced4da;
  border-radius: 6px;
  font-family: inherit;
  resize: vertical;
  color: #495057;
}

.description-input:focus {
  outline: none;
  border-color: #3498db;
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

.story-editor {
  flex: 1;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  border: 1px solid #e1e5e9;
  display: flex;
}

.story-textarea {
  flex: 1;
  padding: 25px;
  border: none;
  resize: none;
  font-family: 'Georgia', 'Times New Roman', serif;
  font-size: 1.1rem;
  line-height: 1.6;
  color: #2c3e50;
  background: transparent;
  border-radius: 8px;
}

.story-textarea:focus {
  outline: none;
}

.story-textarea::placeholder {
  color: #adb5bd;
  font-style: italic;
}

/* Responsive design */
@media (max-width: 768px) {
  .editor-header {
    padding: 10px 15px;
    flex-direction: column;
    gap: 10px;
    text-align: center;
  }

  .editor-info {
    order: -1;
  }

  .editor-content {
    padding: 15px;
  }

  .story-textarea {
    padding: 15px;
    font-size: 1rem;
  }
}

================================================================================
## FILE: frontend/src\pages\ProjectEditorPage.tsx

// frontend/src/pages/ProjectEditorPage.tsx
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useProject } from '../hooks/useProjects';
import { useStoryContent, useContentVersions } from '../hooks/useStoryContent';
import { useProjectStats } from '../hooks/useProjects';
import LoadingSpinner from '../components/common/LoadingSpinner';
import ErrorMessage from '../components/common/ErrorMessage';
import './ProjectEditorPage.css';

const ProjectEditorPage: React.FC = () => {
  const { projectId } = useParams<{ projectId: string }>();
  const navigate = useNavigate();
  const numericProjectId = parseInt(projectId || '0', 10);

  const { project, isLoading: projectLoading, error: projectError } = useProject(numericProjectId);
  const { stats } = useProjectStats(numericProjectId);
  const {
    content,
    isLoading: contentLoading,
    isSaving,
    isAutoSaving,
    hasUnsavedChanges,
    lastSaved,
    error: contentError,
    updateContent,
    saveContent: forceSave,
    createVersion,
  } = useStoryContent(numericProjectId);

  const { versions, refreshVersions } = useContentVersions(numericProjectId);

  const [showVersions, setShowVersions] = useState(false);
  const [showStats, setShowStats] = useState(false);
  const [storyText, setStoryText] = useState('');

  const isLoading = projectLoading || contentLoading;
  const error = projectError || contentError;

  useEffect(() => {
    if (!projectId || isNaN(numericProjectId)) {
      navigate('/projects');
    }
  }, [projectId, numericProjectId, navigate]);
  
  useEffect(() => {
    if (content?.content !== undefined) {
      setStoryText(content.content);
    }
  }, [content]);

  useEffect(() => {
    updateContent(storyText);
  }, [storyText, updateContent]);

  // Manual save with Ctrl+S
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        if (hasUnsavedChanges) {
          forceSave();
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [forceSave, hasUnsavedChanges]);

  const handleBackToDashboard = () => {
    if (hasUnsavedChanges) {
      const confirmLeave = window.confirm('You have unsaved changes. Are you sure you want to leave?');
      if (!confirmLeave) {
        return;
      }
    }
    navigate('/projects');
  };

  const handleSaveAndCreateVersion = async () => {
    const saveSuccess = await forceSave();
    if (saveSuccess) {
      const versionSuccess = await createVersion();
      if (versionSuccess) {
        refreshVersions();
        alert('Version created successfully!');
      }
    }
  };

  const formatLastSaved = (timestamp?: string) => {
    if (!timestamp) {
      return 'Never';
    }
    const date = new Date(timestamp);
    return date.toLocaleTimeString();
  };

  const getStatusIndicator = () => {
    if (isSaving) {
      return { text: 'Saving...', class: 'saving' };
    }
    if (isAutoSaving) {
      return { text: 'Auto-saving...', class: 'auto-saving' };
    }
    if (hasUnsavedChanges) {
      return { text: 'Unsaved changes', class: 'unsaved' };
    }
    return { text: 'All changes saved', class: 'saved' };
  };

  const statusIndicator = getStatusIndicator();

  if (isLoading) {
    return (
      <div className="editor-loading">
        <LoadingSpinner />
        <p>Loading project...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="editor-error">
        <ErrorMessage message={error} />
        <button onClick={handleBackToDashboard} className="btn btn-secondary">
          Back to Projects
        </button>
      </div>
    );
  }

  if (!project) {
    return (
      <div className="editor-error">
        <ErrorMessage message="Project not found" />
        <button onClick={handleBackToDashboard} className="btn btn-secondary">
          Back to Projects
        </button>
      </div>
    );
  }

  return (
    <div className="project-editor-page">
      {/* Editor Toolbar */}
      <div className="editor-toolbar">
        <div className="toolbar-left">
          <button
            onClick={handleBackToDashboard}
            className="btn btn-secondary btn-sm"
            title="Back to Projects"
          >
            ← Back
          </button>
          <h2 className="project-title">{project.title}</h2>
        </div>

        <div className="toolbar-center">
          <div className={`save-status ${statusIndicator.class}`}>
            <span className="status-dot"></span>
            {statusIndicator.text}
            {lastSaved && (
              <small className="last-saved">
                Last saved: {formatLastSaved(lastSaved)}
              </small>
            )}
          </div>
          {stats && <div className="word-count-display">{stats.word_count.toLocaleString()} words</div>}
        </div>

        <div className="toolbar-right">
          <button
            onClick={() => setShowStats(!showStats)}
            className="btn btn-outline btn-sm"
            title="Toggle Statistics"
          >
            Stats
          </button>

          <button
            onClick={() => setShowVersions(!showVersions)}
            className="btn btn-outline btn-sm"
            title="Version History"
          >
            Versions
          </button>

          <button
            onClick={handleSaveAndCreateVersion}
            className="btn btn-secondary btn-sm"
            disabled={isSaving}
            title="Save and Create Version"
          >
            Save Version
          </button>

          <button
            onClick={() => forceSave()}
            className="btn btn-primary btn-sm"
            disabled={isSaving || (!hasUnsavedChanges && !isAutoSaving)}
            title="Save Now (Ctrl+S)"
          >
            {isSaving ? 'Saving...' : 'Save'}
          </button>
        </div>
      </div>

      <div className="editor-main">
        {/* Side Panel */}
        {(showStats || showVersions) && (
          <div className="editor-sidebar">
            {showStats && stats && (
              <div className="stats-panel">
                <h3>Statistics</h3>
                <div className="stat-item">
                  <label>Word Count:</label>
                  <span>{stats.word_count.toLocaleString()}</span>
                </div>
                {stats.target_word_count && (
                  <div className="stat-item">
                    <label>Target:</label>
                    <span>{stats.target_word_count.toLocaleString()}</span>
                  </div>
                )}
                <div className="stat-item">
                  <label>Characters:</label>
                  <span>{stats.character_count.toLocaleString()}</span>
                </div>
                {stats.progress_percentage > 0 && (
                  <div className="stat-item">
                    <label>Progress:</label>
                    <div className="progress-bar">
                      <div
                        className="progress-fill"
                        style={{ width: `${Math.min(100, stats.progress_percentage)}%` }}
                      ></div>
                      <span className="progress-text">
                        {Math.round(stats.progress_percentage)}%
                      </span>
                    </div>
                  </div>
                )}
                <div className="stat-item">
                  <label>Days Active:</label>
                  <span>{stats.days_since_creation}</span>
                </div>
              </div>
            )}

            {showVersions && (
              <div className="versions-panel">
                <h3>Version History</h3>
                <div className="versions-list">
                  {versions.map((version) => (
                    <div
                      key={version.id}
                      className={`version-item ${version.is_active ? 'active' : ''}`}
                    >
                      <div className="version-info">
                        <strong>Version {version.version}</strong>
                        {version.is_active && <span className="active-badge">Current</span>}
                        <small>{new Date(version.created_at).toLocaleDateString()}</small>
                      </div>
                      <div className="version-meta">
                        <span className="save-reason">{version.save_reason}</span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}

        {/* Main Editor */}
        <div className="editor-content-wrapper">
          <textarea
            value={storyText}
            onChange={(e) => setStoryText(e.target.value)}
            placeholder="Start writing your story..."
            className="story-textarea"
            disabled={isLoading}
          />
        </div>
      </div>
    </div>
  );
};

export default ProjectEditorPage;
================================================================================
## FILE: frontend/src\pages\ProjectsDashboard.css

/* Projects Dashboard styles placeholder */

================================================================================
## FILE: frontend/src\pages\ProjectsDashboard.tsx

// frontend/src/pages/ProjectsDashboard.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useProjects } from '../hooks/useProjects';
import { Project } from '../types/project-types';
import ProjectList from '../components/projects/ProjectList';
import CreateProjectForm from '../components/projects/CreateProjectForm';
import DeleteProjectModal from '../components/projects/DeleteProjectModal';
import './ProjectsDashboard.css';

const ProjectsDashboard: React.FC = () => {
  const navigate = useNavigate();
  const {
    projects,
    isLoading,
    error,
    pagination,
    createProject,
    deleteProject,
    setPage,
    clearError
  } = useProjects();

  const [showCreateForm, setShowCreateForm] = useState(false);
  const [projectToDelete, setProjectToDelete] = useState<Project | null>(null);

  const handleCreateProject = () => {
    setShowCreateForm(true);
  };

  const handleProjectCreated = async (projectData: any) => {
    const newProject = await createProject(projectData);
    if (newProject) {
      setShowCreateForm(false);
    }
  };

  const handleProjectSelect = (projectId: number) => {
    navigate(`/projects/${projectId}/editor`);
  };

  const handleProjectEdit = (project: Project) => {
    navigate(`/projects/${project.id}/settings`);
  };

  const handleProjectDelete = (projectId: number) => {
    const project = projects.find(p => p.id === projectId) || null;
    setProjectToDelete(project);
  };

  const confirmDelete = async () => {
    if (projectToDelete) {
      const success = await deleteProject(projectToDelete.id);
      if (success) {
        setProjectToDelete(null);
      }
    }
  };


  return (
    <div className="projects-dashboard">
      <div className="dashboard-header">
        <div className="header-content">
          <h1>My Writing Projects</h1>
          <button 
            className="btn btn-primary"
            onClick={handleCreateProject}
          >
            + New Project
          </button>
        </div>
      </div>

      <div className="dashboard-content">
        {error && (
          <div className="error-alert">
            <span>{error}</span>
            <button onClick={clearError} className="close-btn">×</button>
          </div>
        )}

        <ProjectList
          projects={projects}
          isLoading={isLoading}
          onCreateNew={handleCreateProject}
          onProjectSelect={handleProjectSelect}
          onProjectEdit={handleProjectEdit}
          onProjectDelete={handleProjectDelete}
        />

        {pagination.pages > 1 && (
          <div className="pagination">
            {Array.from({ length: pagination.pages }, (_, i) => i + 1).map(page => (
              <button
                key={page}
                className={`page-btn ${pagination.page === page ? 'active' : ''}`}
                onClick={() => setPage(page)}
              >
                {page}
              </button>
            ))}
          </div>
        )}
      </div>

      {/* Create Project Modal */}
      {showCreateForm && (
        <div className="modal-overlay">
          <div className="modal">
            <CreateProjectForm
              onSubmit={handleProjectCreated}
              onCancel={() => setShowCreateForm(false)}
            />
          </div>
        </div>
      )}

      {/* Delete Confirmation Modal */}
      {projectToDelete && (
        <DeleteProjectModal
          project={projectToDelete}
          onConfirm={confirmDelete}
          onCancel={() => setProjectToDelete(null)}
        />
      )}
    </div>
  );
};

export default ProjectsDashboard;
================================================================================
## FILE: frontend/src\pages\RegisterPage.tsx

// frontend/src/pages/RegisterPage.tsx
import React from 'react';
import RegisterForm from '../components/auth/RegisterForm';

const RegisterPage: React.FC = () => (
  <div className="register-page">
    <RegisterForm />
  </div>
);

export default RegisterPage;

================================================================================
## FILE: frontend/src\services\project-api.ts

import axios from 'axios';
import {
  Project,
  ProjectCreate,
  ProjectUpdate,
  ProjectWithContent,
  ProjectListResponse,
  ProjectStats,
  ProjectBackup,
  ProjectFilters,
  StoryContent,
  StoryContentUpdate,
} from '../types/project-types';

// Get the API base URL from environment or default
const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';

// Create axios instance with default config (only once!)
const apiClient = axios.create({
  baseURL: `${API_BASE_URL}/api`,
  headers: { 'Content-Type': 'application/json' }
});

// Add auth token to requests
apiClient.interceptors.request.use(config => {
  const token = localStorage.getItem('access_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Handle response errors globally
apiClient.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 401) {
      localStorage.removeItem('access_token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export const projectAPI = {
  async getProjects(filters: ProjectFilters = {}): Promise<ProjectListResponse> {
    const params = new URLSearchParams();
    if (filters.skip !== undefined) {
      params.append('skip', filters.skip.toString());
    }
    if (filters.limit !== undefined) {
      params.append('limit', filters.limit.toString());
    }
    if (filters.status) {
      params.append('status', filters.status);
    }
    if (filters.genre) {
      params.append('genre', filters.genre);
    }
    if (filters.search) {
      params.append('search', filters.search);
    }
    const response = await apiClient.get<ProjectListResponse>(`/projects?${params.toString()}`);
    return response.data;
  },
  async getProject(projectId: number): Promise<ProjectWithContent> {
    const response = await apiClient.get<ProjectWithContent>(`/projects/${projectId}`);
    return response.data;
  },
  async createProject(projectData: ProjectCreate): Promise<Project> {
    const response = await apiClient.post<Project>('/projects', projectData);
    return response.data;
  },
  async updateProject(projectId: number, projectData: ProjectUpdate): Promise<Project> {
    const response = await apiClient.put<Project>(`/projects/${projectId}`, projectData);
    return response.data;
  },
  async deleteProject(projectId: number): Promise<{ message: string }> {
    const response = await apiClient.delete<{ message: string }>(`/projects/${projectId}`);
    return response.data;
  },
  async getProjectStats(projectId: number): Promise<ProjectStats> {
    const response = await apiClient.get<ProjectStats>(`/projects/${projectId}/stats`);
    return response.data;
  },
  async getStoryContent(projectId: number): Promise<StoryContent> {
    const response = await apiClient.get<StoryContent>(`/stories/${projectId}/content`);
    return response.data;
  },
  async saveStoryContent(projectId: number, contentData: StoryContentUpdate): Promise<StoryContent> {
    const response = await apiClient.put<StoryContent>(`/stories/${projectId}/content`, contentData);
    return response.data;
  },
  async autoSaveStoryContent(projectId: number, content: string): Promise<{ message: string }> {
    const response = await apiClient.post<{ message: string }>(`/stories/${projectId}/auto-save`, {
      content,
      auto_saved: true,
      save_reason: 'auto_save',
    });
    return response.data;
  },
  async createContentVersion(projectId: number): Promise<StoryContent> {
    const response = await apiClient.post<StoryContent>(`/stories/${projectId}/content/version`);
    return response.data;
  },
  async getContentVersions(projectId: number): Promise<StoryContent[]> {
    const response = await apiClient.get<StoryContent[]>(`/stories/${projectId}/content/versions`);
    return response.data;
  },
  async restoreContentVersion(projectId: number, version: number): Promise<{ message: string }> {
    const response = await apiClient.post<{ message: string }>(`/stories/${projectId}/content/restore/${version}`);
    return response.data;
  },
  async backupContent(projectId: number): Promise<ProjectBackup> {
    const response = await apiClient.get<ProjectBackup>(`/stories/${projectId}/content/backup`);
    return response.data;
  }
};

export default projectAPI;

// Utility functions for error handling
export const handleApiError = (error: any): string => {
  if (error.response?.data?.detail) {
    return error.response.data.detail;
  }
  if (error.message) {
    return error.message;
  }
  return 'An unexpected error occurred';
};

// Auto-save utility class
export class AutoSaveManager {
  private timeoutId: ReturnType<typeof setTimeout> | null = null;
  private readonly projectId: number;
  private readonly delay: number;

  constructor(projectId: number, delay: number = 3000) {
    this.projectId = projectId;
    this.delay = delay;
  }

  scheduleAutoSave(content: string, callback?: () => void): void {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
    this.timeoutId = setTimeout(async () => {
      try {
        await projectAPI.autoSaveStoryContent(this.projectId, content);
        callback?.();
      } catch (error) {
        console.error('Auto-save failed:', error);
      }
    }, this.delay);
  }

  cancel(): void {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }

  destroy(): void {
    this.cancel();
  }
}

================================================================================
## FILE: frontend/src\types\auth-types.ts

// frontend/src/types/auth-types.ts
export interface User {
  id: number;
  username: string;
  email: string;
  created_at: string;
  is_active: boolean;
}

export interface LoginRequest {
  username: string;
  password: string;
}

export interface RegisterRequest {
  username: string;
  email: string;
  password: string;
}

export interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  login: (username: string, password: string) => Promise<boolean>;
  register: (username: string, email: string, password: string) => Promise<boolean>;
  logout: () => void;
  isLoading: boolean;
  authError: string;
  clearAuthError: () => void;
}

================================================================================
## FILE: frontend/src\types\project-types.ts

// frontend/src/types/project-types.ts
export interface Project {
  id: number;
  title: string;
  description?: string;
  genre?: string;
  status: ProjectStatus;
  is_private: boolean;
  word_count: number;
  target_word_count?: number;
  user_id: number;
  created_at: string;
  updated_at?: string;
  last_edited_at?: string;
}

export interface ProjectCreate {
  title: string;
  description?: string;
  genre?: string;
  status?: ProjectStatus;
  is_private?: boolean;
  target_word_count?: number;
}

export interface ProjectUpdate {
  title?: string;
  description?: string;
  genre?: string;
  status?: ProjectStatus;
  is_private?: boolean;
  target_word_count?: number;
}

export interface ProjectWithContent extends Project {
  content?: StoryContent;
}

export interface StoryContent {
  id: number;
  project_id: number;
  content?: string;
  content_type: ContentType;
  version: number;
  is_active: boolean;
  auto_saved: boolean;
  save_reason: SaveReason;
  created_at: string;
  updated_at?: string;
}

export interface StoryContentUpdate {
  content?: string;
  auto_saved?: boolean;
  save_reason?: SaveReason;
}

export interface ProjectListResponse {
  projects: Project[];
  total: number;
  page: number;
  size: number;
  pages: number;
}

export interface ProjectStats {
  project_id: number;
  word_count: number;
  target_word_count?: number;
  character_count: number;
  progress_percentage: number;
  days_since_creation: number;
  last_edited?: string;
}

export interface ProjectBackup {
  project: {
    id: number;
    title: string;
    description?: string;
    genre?: string;
    status: string;
    created_at: string;
    word_count: number;
  };
  content_versions: Array<{
    version: number;
    content?: string;
    content_type: string;
    is_active: boolean;
    created_at: string;
    save_reason: string;
  }>;
  backup_created_at: string;
}

// Enums
export type ProjectStatus = 'draft' | 'in_progress' | 'completed' | 'published';

export type ContentType = 'markdown' | 'html' | 'plain_text';

export type SaveReason = 
  | 'manual_save' 
  | 'auto_save' 
  | 'version_save' 
  | 'initial_creation' 
  | 'version_restore';

// Filter and query types
export interface ProjectFilters {
  status?: ProjectStatus;
  genre?: string;
  search?: string;
  skip?: number;
  limit?: number;
}

// UI State types
export interface ProjectEditorState {
  isLoading: boolean;
  isSaving: boolean;
  isAutoSaving: boolean;
  hasUnsavedChanges: boolean;
  lastSaved?: string;
  error?: string;
  content: StoryContent | null;
}

export interface ProjectListState {
  projects: Project[];
  isLoading: boolean;
  error?: string;
  filters: ProjectFilters;
  pagination: {
    page: number;
    size: number;
    total: number;
    pages: number;
  };
}

// Form validation types
export interface ProjectFormErrors {
  title?: string;
  description?: string;
  genre?: string;
  target_word_count?: string;
}

// Genre options for dropdowns
export const GENRE_OPTIONS = [
  'Fiction',
  'Non-Fiction',
  'Romance',
  'Mystery',
  'Fantasy',
  'Science Fiction',
  'Thriller',
  'Horror',
  'Adventure',
  'Young Adult',
  'Children\'s',
  'Biography',
  'Memoir',
  'Self-Help',
  'Business',
  'Poetry',
  'Other'
] as const;

// Status options
export const STATUS_OPTIONS: { value: ProjectStatus; label: string; color: string }[] = [
  { value: 'draft', label: 'Draft', color: 'gray' },
  { value: 'in_progress', label: 'In Progress', color: 'blue' },
  { value: 'completed', label: 'Completed', color: 'green' },
  { value: 'published', label: 'Published', color: 'purple' }
];

// API Response types
export interface ApiError {
  detail: string;
}

export interface ApiResponse<T> {
  data?: T;
  error?: ApiError;
}

// Component Props types
export interface ProjectCardProps {
  project: Project;
  onEdit: (project: Project) => void;
  onDelete: (projectId: number) => void;
  onOpen: (projectId: number) => void;
}

export interface ProjectListProps {
  projects: Project[];
  isLoading: boolean;
  onCreateNew: () => void;
  onProjectSelect: (projectId: number) => void;
  onProjectEdit: (project: Project) => void;
  onProjectDelete: (projectId: number) => void;
  filters: ProjectFilters;
  onFiltersChange: (filters: ProjectFilters) => void;
}

export interface ProjectEditorProps {
  projectId: number;
  onSave: (content: string) => void;
  onAutoSave: (content: string) => void;
  autoSaveInterval?: number; // in milliseconds
}